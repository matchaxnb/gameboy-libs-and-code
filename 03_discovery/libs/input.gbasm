;; format:

; poll input
; @returns input state in register a
; 
PollInput:
    ;; poll buttons
    ld a, P1F_GET_BTN
    ld [rP1], a
    REPT 8
        ld a, [rP1]
        nop
    ENDR
    xor a, 0x0f ; xor because 0 -> on, 1 -> off
    and a, 0x0f ; clean top bits
    ld b, a ; copy to b
    ;; now B contains 0000STBA
    ;; poll DPAD
    ld a, P1F_GET_DPAD
    ld [rP1], a
    REPT 8
        ld a, [rP1]
        nop
    ENDR
    xor a, 0x0f 
    and a, 0x0f ; clean top nibs
    swap a ; exchange nibs, a is DULR0000
    or a, b   ; merge the 2 halves, a is DULRSTBA
ret

; based on the polled input, update the various objects
; @input register A, containing the input state
; modifies registers B, C, D, E, H as work registers
; B: previously polled keys [stored in wPrevKeys]
; C: newly polled keys [stored in wCurKeys]
; D: what keys are newly pressed  [stored in wNewlyPressed]
; E: what keys are newly released [stored in wNewlyReleased]
SetInputState:
    ;; store current and previous input status
    ld c, a ; C <- A (current input status)
    ldh a, [wCurKeys] ; A <- (previous input status)
    ld b, a ; B <- previous input status
    ldh [wPrevKeys], a ; $prevKeys <- old curKeys
    ld a, c ; A <- current input status
    ldh [wCurKeys], a ; $curKeys <- new input status
    ;; compute changes
    ld a, b ; A <- previous input status
    xor a, c ; A <- B ^ C (toggle mask, what has changed)
    ld h, a ; H <- toggle mask, 1 means the key has changed state
    ;; what is newly pressed
    ld a, c ; A <- current input state
    and a, h ; A <- A & what has changed

    ld [wNewlyPressed], a
    ld d, a ; D <- newly pressed
    ;; what is newly released
    ld a, c ; A <- current input state
    cpl ; what is NOT pressed
    and a, h; what has changed and is not pressed
    ld [wNewlyReleased], a
    ld e, a
ret


