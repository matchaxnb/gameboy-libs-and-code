DEF COMPACT_AUDIO_PKTSIZE = 2

; load a compact music chunk into CH1 or CH2
; read from register \2
; @param \1: CH1 or CH2
MACRO AU_LoadCompactMusicIntoCH1OrCH2
    call LoadCompactMusic\1
ENDM

; define fun to load music chunk into CH1 or CH2
; read from register hl
; @param \1: CH1 or CH2
MACRO AU_DefCompactMusicIntoCH1OrCH2
ASSERT  STRCMP("\1", "CH1") * STRCMP("\1", "CH2") == 0
if (STRCMP("\1", "CH1") == 0)
DEF _BASE_REG = rAUD1LEN
else
DEF _BASE_REG = rAUD2LEN
ENDC
    LoadCompactMusic\1:
        push de
        push bc
        push hl
        ;; first load duration into right register
        ld a, [hli]
        ld d, a ; store duration to d
        and a, $7f ; remove top bit from duration
        ldh [wMusicTimer\1], a ; load masked duration to timer
        bit 7, d
        jr nz, .silence\@
        ;; now we know we won't have silence, move to next word to handle pitch
        ld a, [hl] ; a <- pitch offset
        ldaTo bc ; bc <- a
        ld hl, PitchesTable ; 
        add hl, bc
        add hl, bc ; we repeat because we handle 16-bit words
        
        ld a, [hli] ; a <- [hl], hl++
        ldh [_BASE_REG + 2], a ; <- bottom period bits (NR13)
        ld a, [hl] ; a <- top period bits
        or a, $80 ; set trigger, no length enable

        jr .end\@
        .silence\@
            ; no trigger -> silence
        ld a, 0
        .end\@
        ldh [_BASE_REG + 3], a ; <- top bits (NR14)
        pop hl
        pop bc
        pop de
    ret
ENDM

; macro to play a compact track on a channel
; @param \1 CH1 or CH2
; @param \2 starting location (resolve to a label)
; @param \3 duration in packets (offsetEnd - offsetStart) / COMPACT_AUDIO_PKTSIZE
; @param \4 looping point
; @param \5 duty cycle
; @param \6 initial volume (0-15)
; @param \7 envelope direction (1: increase, 0: decrease)
; @param \8 envelope speed (0-7, 0 disables the envelope)
MACRO CompactPlayAudio_CH1orCH2
ASSERT  STRCMP("\1", "CH1") * STRCMP("\1", "CH2") == 0
ASSERT \3 < 256
ASSERT \6 >= 0 && \6 < 16
ASSERT (\7 & 1 == \7)
ASSERT (\8 >= 0 && \8 < 8)
if (STRCMP("\1", "CH1") == 0)
DEF _BASE_REG = rNR11
ELSE
DEF _BASE_REG = rNR21
ENDC
PRINT "Generating function AudioPlay_"
PRINT \2
PRINTLN " with register {_BASE_REG}, duty cycle \5 and looping point \4"
    AudioPlay_\2:
        push de
        ldh a, [wMusicOffset\1]
        ld e, a ; e <- music offset
        cp a, 0
        jr nz, .afterChannelSetup\@
        ; here, setup channel
        ld a, (\5 << 6) ; 
        ldh [_BASE_REG], a ; setup duty cycle
        ld a, (\6 << 4) | ((\7 & 1) << 3) | \8
        ldh [_BASE_REG+1], a ; setup envelope thingies
        ld a, e ; restore offset to a
        .afterChannelSetup\@
        cp a, \3
        jr c, .afterReset\@ ; if curOffset - (duration) is negative, no need to reset
        ;; here we need to reset to the looping point
        ld a, \4 ; a <- looping point
        ldh [wMusicOffset\1], a ; store 
        ld e, \4 ; e <- looping point
        .afterReset\@
        ldh a, [wMusicTimer\1]
        ld d, a ; d <- music timer
        cp a, 0
        jr nz, .endOfWork\@
        ;; if we're here, we need to load a packet
        ; d is 0, e is the offset, so de is the offset
        ;; let's make sure
        
        ld a, [wMusicOffset\1]
        ldaTo de
        ld hl, \2
        REPT COMPACT_AUDIO_PKTSIZE
            add hl, de
        ENDR
        ;; now hl has the packet to load
        call LoadCompactMusic\1 ;; this is a call
        ; retrieve offset from work mem
        ldh a, [wMusicOffset\1]
        inc a
        ldh [wMusicOffset\1], a ; store new offset to offset flag
        .endOfWork\@
        ; decrease the timer
        ldh a, [wMusicTimer\1]
        dec a
        ldh [wMusicTimer\1], a
        pop de
    ret
ENDM


; macro to define a more compact music format
; assumes that the synth parameters are already set
; @param \1 pitch offset (in words) relative to PitchesTable (starts at C2, ends at Gb5, + Silence)
; @param \2 duration (in music ticks). top bit is silence flag. if top bit is set, expect pitch to be 0
; stored in 2 bytes (1 word)
MACRO AU_CompactMusic
    ASSERT (\1 >= 0 && \1 < ((PitchesTableEnd - PitchesTable) / 2))
    ASSERT (\2 & 0x80 == 0x80 && \1 == PitchesTable.Sil - PitchesTable) || (\2 != 0x80)
    db \2 ; store duration
    db \1 ; then store offset to PitchesTable
ENDM



; @param \1 Note (from C1 to Gb5)
; @param \2 Duration (in 32th notes)
MACRO PianoNoteShort
ASSERT Pitches.\1
ASSERT \2 < 0x80

DEF _REALOFFSET = ((Pitches.\1) - PitchesTable)
DEF _N = _REALOFFSET / 2
PRINTLN STRFMT("PianoNoteShort \1 duration \2 offset %d cr: %d", _N, CONVERSION_RATIO)
AU_CompactMusic _N, \2
PURGE _REALOFFSET
PURGE _N
ENDM

; @param \1 Duration (in 16th notes)
MACRO PianoRestShort
ASSERT \1 < 0x80
DEBUGPLN STRFMT("PianoRest \1 cr: %d", CONVERSION_RATIO)

DEF _N = (Pitches.Sil - PitchesTable) / 2
PRINT "Silence has offset "
PRINTLN _N
AU_CompactMusic _N, \1 | 0x80
PURGE _N
ENDM