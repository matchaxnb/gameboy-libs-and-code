INCLUDE "macros/audio_midi.gbasm"

MACRO AU_LoadIntoCH1orCH2
ASSERT STRCMP("\1", "CH1") * STRCMP("\1", "CH2") == 0

if (STRCMP("\1", "CH1") == 0)
DEF _BASE_REG = rAUD1LEN
else
DEF _BASE_REG = rAUD2LEN
ENDC
FOR N, 0, 4, 1
.load\1_\@
    ld a, [hli]
    ld [_BASE_REG + N], a
ENDR
ld a, [hli]
and a, %11111000 ; keep only flags, not counter chunk
or d ; get current flags
ldh [wMusicFlags\1], a
ld a, [hli]
ldh [wMusicTimer\1], a  ;; load timer for CH1
xor a
; ldh [wMusicOffset\1], a
PURGE _BASE_REG
ENDM

; put address to load into hl
; mutates af and hl
MACRO AU_LoadIntoCH1
AU_LoadIntoCH1orCH2 CH1
ENDM

MACRO AU_LoadIntoCH2
AU_LoadIntoCH1orCH2 CH2
ENDM
; macro to define words in ROM musically
; @param \1 wave pattern duty 
; %00 -> 12.5%; %01 -> 25%, %10 -> 50%, %11 -> 75%
; @param \2 length (0-63) (ignored if length is set to false (smaller is longer))
; @param \3 period (0-2047 or one of the constants XXX_PERIOD in audio_midi.gbasm)
; @param \4 trigger immediately (0-1)
; @param \5 enable length (0-1)
; @param \6 initial volume (0-15)
; @param \7 envelope up (0-1)
; @param \8 envelope speed (higher values -> shorter envelope / 0: no envelope) (0-7)
; @param \9 time to set in timer (0-255)
; @output definition of 4 bytes corresponding to these parameters as expected from registers NRx1->NRx4
; set CH1/CH2 data (without the NR10 sweep settings)
; can be applied to CH1 and CH2 (equivalent of NR11->NR14/NR21->NR24)
MACRO AU_DataPacked
ASSERT ((\1 >= 0) && \1 < %100)
ASSERT ((\2 >= 0)  && \2 < 64)
ASSERT (\3 >= 0 && \3 < 2048)
ASSERT (\4 == 0 || \4 == 1)
ASSERT (\5 == 0 || \5 == 1)
ASSERT (\6 >= 0 && \6 < 16)
ASSERT (\7 == 0 || \7 == 1)
ASSERT (\8 >= 0 && \8 < 16)
ASSERT (\9 >= 0 && \9 < 256)
db  (\1 << 6) | (\2 & %111111)                                  ;; NRx1
db  ((\6 & %1111) << 4) | (\7 & %1) << 3 | (\8 & %111)          ;; NRx2
db  (\3 & 0xff)                                                 ;; NRx3
db  ((\3 >> 8) & %111) | ((\5 & %1) << 6 ) | ((\4 & %1) << 7)   ;; NRx4
db  $00 | (\5 ^ %10000000)                                      ;; Flags
db  \9 - 1                                                      ;; Timer
ENDM

; define a function to play a given track on channel 1-2 and apply looping points
; @param \1 channel name (CH1 or CH2)
; @param \2 track name (should resolve to an existing label that points to the first audio packet in track
; @param \3 duration (number of audio blocks for that song)
; @param \4 looping point (0-based index to loop from when at song end)
; @output a function called AudioPlay_\2 
MACRO AudioC1C2PlayTrack
if (\3 < 255)
PRINTLN "Using AudioC1C2PlayTrack_SmallOffset \1 \2 \3 \4"
AudioC1C2PlayTrack_SmallOffset \1, \2, \3, \4
else
PRINTLN "Using AudioC1C2PlayTrack_BigOffset \1 \2 \3 \4"
AudioC1C2PlayTrack_BigOffset \1, \2, \3, \4
endc
ENDM


; define a function to play a given track on channel 1-2 and apply looping points
; @param \1 channel name (CH1 or CH2)
; @param \2 track name (should resolve to an existing label that points to the first audio packet in track
; @param \3 duration (number of audio blocks for that song)
; @param \4 looping point (0-based index to loop from when at song end)
; @output a function called AudioPlay_\2 
MACRO AudioC1C2PlayTrack_SmallOffset
    ASSERT (STRCMP("\1", "CH1") * STRCMP("\1", "CH2") == 0)
    ASSERT \3 < 255
    if STRCMP("\1", "CH1") == 0
    DEF _REGISTER_TO_WRITE = rNR11
    else
    DEF _REGISTER_TO_WRITE = rNR21
    endc
    AudioPlay_\2:
        ld d, 0
        ldh a, [wMusicFlags\1]
        ld h, a
        ldh a, [wMusicTimer\1] ;; load timer for CH1
        ld l, a
        cp a, 0
        jr nz, .nostoTimer\1\@   ;; if timer is not zero, not yet time to load
        jr .load\1\@             ;; if it's 0, load CH1
    .nostoTimer\1\@
        bit 0, h ; test for bit 0 (hold) of flags
        jr z, .noHold\1\@
        ; if hold is set, read the NRx1 register to get duty and rewrite it
        ldh a, [_REGISTER_TO_WRITE]
        and a, %11000000 ; keep only the duty cycle bytes, set the others to 0
        ldh [_REGISTER_TO_WRITE], a
        ; restore timer to register a now
        ld a, l
    .noHold\1\@
        dec a
        ldh [wMusicTimer\1], a  ;; store timer
        jr .noload\1\@          ;; and that's it, "return"
    .load\1\@
        ; otherwise load a music chunk to the registers
        ; retrieve current offset from HRAM
        ldh a, [wMusicOffset\1]
        inc a
        ; compare it to the track duration
        cp a, \3 + 1
        jr nz, .noReset\1\@
        ld a, \4
    .noReset\1\@
        ; store new offset to HRAM
        ldh [wMusicOffset\1], a
        ld e, a ; copy stored offset to e
        dec e; 
        ld hl, \2 ;  hl <- base point of track
        REPT AUDIO_PKTSIZE    ;  hl = hl + (offset * AUDIO_PKTSIZE) 0: hl, 1: hl+5, 2: hl + 10, 3: hl + 15...
        add hl, de
        ENDR       ;; seek to right position in audio file
        AU_LoadInto\1        ;; load data into CH1
    .noload\1\@
    ret
    PURGE _REGISTER_TO_WRITE
ENDM

; define a function to play a given track on channel 1-2 and apply looping points
; that has a long duration (> 255 chunks)
; @param \1 channel name (CH1 or CH2)
; @param \2 track name (should resolve to an existing label that points to the first audio packet in track
; @param \3 duration (number of audio blocks for that song)
; @param \4 looping point (0-based index to loop from when at song end)
; @output a function called AudioPlay_\2 
MACRO AudioC1C2PlayTrack_BigOffset
    ASSERT (STRCMP("\1", "CH1") * STRCMP("\1", "CH2") == 0)
    ASSERT \3 >= 255
    if STRCMP("\1", "CH1") == 0
    DEF _REGISTER_TO_WRITE = rNR11
    else
    DEF _REGISTER_TO_WRITE = rNR21
    endc
    AudioPlay_\2:
        push de
        push hl
        ld d, 0
        ldh a, [wMusicFlags\1]
        ld h, a ; h <- wMusicFlags
        ldh a, [wMusicTimer\1] ;; load timer for CH1
        ld l, a ; l <- timer (8 bit counter)
        cp a, 0
        jr nz, .stillWaiting\1\@   ;; if timer is not zero, not yet time to load
        jr .load\1\@             ;; if it's 0, load CH1
    .stillWaiting\1\@
        ;; test if we should hold
        bit 7, h ; test for bit 7 (hold) of flags
        jr z, .afterHold\1\@ ;; if we do not hold, skip the hold section
        ; if hold is set, read the NRx1 register to get duty and rewrite it
        ldh a, [_REGISTER_TO_WRITE]
        and a, %11000000 ; keep only the duty cycle bytes, set the others to 0
        ldh [_REGISTER_TO_WRITE], a
        ; restore timer to register a now
        ld a, l
    .afterHold\1\@
        dec a
        ldh [wMusicTimer\1], a  ;; store decreased timer
        jr .exit\1\@          ;; and that's it, exit the function
    .load\1\@
        ; otherwise load a music chunk to the registers
        ;;;;;;; retrieve current offset from HRAM to de
        
        ld a, [wMusicOffset\1]
        ld e, a
        ld a, h ; a <- flags
        and a, %00000111 ; keep only counter part
        ld d, a ; d <- top bits of 11-bit counter
        inc de
        cp a, d ; check if we increased d (for example 0x00ff -> 0x0100)
        jr nz, .dIncreased
        jr .dPostIncreased
    .dIncreased
        ; we increased D, so it goes that E increased as well.
        ; save both
        ld a, h ; a <- flags
        and a, %11111000 ; keep only the flags excluding current counter
        or a, d ; concatenate (|) d
        ldh [wMusicFlags\1], a ; save flags to fast ram
        .dPostIncreased
        ld a, e
        ldh [wMusicOffset\1], a ;; save offset 
        jr .postCounterIncrease
    .postCounterIncrease
        ld a, HIGH(\3)
        xor a, d
        jr nz, .postResetCheck
        ld a, LOW(\3)
        xor a, e
        jr nz, .postResetCheck
        ;; do the reset
        ld a, \4
        ld [wMusicOffset\1], a
        ld a, [wMusicFlags\1]
        and %11111000 ;; drop the counter flags
        ld [wMusicFlags\1], a
        ld d, 0
        ld e, \4
    .postResetCheck
        dec de; decrement de to make it the current offset
        ld hl, \2 ;  hl <- base point of track
        REPT AUDIO_PKTSIZE    ;  hl = hl + (offset * AUDIO_PKTSIZE)
        add hl, de
        ENDR       ;; seek to right position in audio file
        inc de; 
        AU_LoadInto\1        ;; load data into adequate channel
    .exit\1\@
        pop hl
        pop de
    ret
    PURGE _REGISTER_TO_WRITE
ENDM





DEF NOMINAL_GB_BPM = (15 * 60 / 8)


; @param \1 Note (from C1 to Gb5)
; @param \2 Duration (in 32th notes)
MACRO PianoNote
IF !DEF(PIANO_DUTY_CYCLE)
DEF PIANO_DUTY_CYCLE = %10
ENDC

IF !DEF(PIANO_INITIAL_VOL)
DEF PIANO_INITIAL_VOL = 15
ENDC

IF !DEF(PIANO_ENVSPD)
DEF PIANO_ENVSPD = 7
ENDC

DEBUGPLN STRFMT("PianoNote \1 duration \2 cr: %d", CONVERSION_RATIO)
AU_DataPacked PIANO_DUTY_CYCLE, 0, PERIOD_\1, \
    1, 0, PIANO_INITIAL_VOL, 0, PIANO_ENVSPD, (\2 * CONVERSION_RATIO)
ENDM

; @param \1 Duration (in 16th notes)
MACRO PianoRest
DEBUGPLN STRFMT("PianoRest \1 cr: %d", CONVERSION_RATIO)
AU_DataPacked %10, 0, PERIOD_Gb5, \
    1, 0, 0, 0, 1, (\1 * CONVERSION_RATIO)
ENDM