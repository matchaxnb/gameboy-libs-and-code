; Get n-th entry address from pakstr text table
; 
; Stores result in register de. Will mutate de as such.
; @param hl Text table start
; @param a  Entry index (0-based) to fetch
GetNthEntryFromTextTable:
    push hl
    push bc
    push af
    ld c, a
    ;; cover trivial case: when entry is 0
    xor a ; 
    xor a, c
    jr nz, .workloop
    ldr16 de, hl ; de <- hl
    jr .exit
.workloop
    ld a, [hl] ; <- load the current item's size (+1) in a
    ldr16 de, hl ; load current hl pos to de
.incloop   
    inc hl ; seek hl forward
    dec a ; incremented 
    jr z, .incdone
    jr .incloop
.incdone
    ; ld a, 0 ; a is 0 at this point (so useless)
    cp c ; is c 0 too?
    jr z, .exit
    dec c ; one less to go
    jr .workloop ; round and round again
.exit
    pop af
    pop bc
    pop hl
ret

; @param hl: Target to copy to
; @param de: Source from which to copy
; format is NEXTENTRYPOS, then string
StrCpy:
    push de
    push hl
    push bc
    ;; extract length to copy
    ld a, [de]
    cp a, 0
    jp z, .endStrcpy ; in case we have a 0-len string, exit
    dec a ; A is actually the pointer to the next elem so we should dec it
    ld b, a ; B <- total len to copy
    inc de ; reach first char to copy
.strcpyLoop
    xor a, a ; a <- 0
    xor b ; is b 0 yet (are we done?)
    jr z, .endStrcpy ; if B == 0, finish
    ld a, [de] ; load char in a
    ld [hl], a ; load char to target
    inc hl     ; source++
    inc de     ; dest ++
    dec b      ; one char less to go
    jr .strcpyLoop ; go over loop
.endStrcpy
    ; ensure there's a \0 at [hl]
    xor a, a
    ld [hl], a
    pop bc
    pop hl
    pop de
ret

; @param hl: Target to copy to
; @param de: Source from which to copy
; @param c: length of string (for cleanup)
; format is NEXTENTRYPOS, then string
; this cleans up the remainder of the string
StrCpyWithCleanup:
    push de
    push hl
    push bc
    ;; extract length to copy
    ld a, [de]
    ldh [$ff80+8], a
    cp a, 0
    jp z, .endStrcpy ; in case we have a 0-len string, exit
    dec a ; A is actually the pointer to the next elem so we should dec it
    ld b, a ; B <- total len to copy
    inc de ; reach first char to copy
.strcpyLoop
    xor a, a ; a <- 0
    cp a, b ; is b 0 yet (are we done?)
    jr z, .endStrcpy ; if B == 0, finish
    ld a, [de] ; load char in a
    ld [hl], a ; load char to target
    inc hl     ; source++
    inc de     ; dest ++
    dec b      ; one char less to go
    dec c      ;  also one less to cleanup

    jr .strcpyLoop ; go over loop
.endStrcpy
    ; ensure there's a \0 at [hl]
    xor a
    cp c
    jr z, .exit
.cleanup
    ld [hli], a
    dec c
    xor a
    cp c
    jr nz, .cleanup
.exit
    pop bc
    pop hl
    pop de
ret

; @param de Which text to write (format LEN, text)
; @param l Which offset in tilemap
TextToTilemap9800:
    ld bc, ($9800)
    ld a, c
    add a, l
    ld c, a ; <- c is now offset
    ;; get length of text
    ld a, [de]
    ld h, a
    inc de
.loop
    ld a, [de] ; load character to a
    ld [bc], a ; copy character to tilemap
    inc bc ; tilemap++
    inc de ; string++
    dec h  ; one less to go
    xor a  ; a = 0
    xor a, h ; is h === 0?
    jr z, .exit
    jr .loop
    
.exit
    pop de
ret 